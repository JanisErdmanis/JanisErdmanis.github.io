<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.png"> <title>Reflecting On the Future of AppBundler</title> <header> <div class=blog-name ><a href="/">Janis Erdmanis</a></div> <nav> <ul> <li><a href="/cv/">CV</a> <li><a href="/blog/">Blog</a> <li><a href="/bookshelf/">BookShelf</a> </ul> </nav> </header> <div class=post-meta >Sep 28, 2024 | 1646 Words</div> <div class=franklin-content > <h1 id=reflecting_on_the_future_of_appbundler ><a href="#reflecting_on_the_future_of_appbundler" class=header-anchor >Reflecting On the Future of AppBundler</a></h1> <p>Deployment of GUI applications has always been a hassle for the developers. Challenges like development complexity for cross-platform targets, distribution, user adoption barriers, and maintainability have reached the point where web page has become a de facto distribution format for any new application development. However, web applications are often not an optimal solution when performance, hardware interfacing, offline functionality and custom visualisations are of concern, which describes requirements for many scientific/industrial software. </p> <p>In recent times, Julia programming language has attained quite a foothold in this area with an unparalleled numerical software ecosystem from plain differential equations and quantum simulations to advanced visualisation frameworks that Makie can offer. GUI frameworks such as Gtk, QML, ImGUI, and Mousetrap are available along with evolving ecosystems around Pluto notebooks and Geary dashboards. However, deploying such applications to users who don&#39;t know or don&#39;t want to know Julia&#39;s workings significantly hinders its adoption for such scenarios. </p> <p>Over the recent years, Julia has attained an unparalleled Artifacts system, allowing the developer to use already compiled binary artefacts via a system known as BinaryBuilder in Julia, which is tightly integrated into Julia&#39;s&#39; package manager. This, for instance, enables easy distribution of project files and instantiating all relevant dependencies via <code>Manifest.toml</code> irrelevant to the operating system used, makes projects written in Julia easy to maintain long-term. As a result GUI applications can be developed on one platform and deployed confidently on another with no modifications whatsoever. This is possible as our favourite GUI frameworks are compiled and distributed across all major desktop operating systems, such as macOS, Linux, Windows, and even FreeBSD, using the BinaryBuilder infrastructure. </p> <p>The recent push from OS vendors to run applications in sandboxed mode has made GUI applications more secure than ever, which can greatly instil confidence in trying out new software. On Linux, it is snap and flatpack; on Windows, it is MSIX format; and on macOS, it&#39;s the entitlement system. The sandboxed mode prevents the applications from gaining access to the parts of the system that the user had not allowed to and prevents the spread of malware. Much like today, we don&#39;t fear about opening webpages on the internet as the Javascript runtime is heavily sandboxed within the browser. However, deploying software into these formats is very challenging as Julia application developers often are not accustomed to thinking about dependency linking and intricacies/limitations within each sandboxed environment and the knowledge how to do so is advancing. </p> <p>The AppBunlder project addresses these latter challenges by vendoring package dependencies and artifacts and offering recipes to cast them into mainstream desktop application installer bundles. The developer only needs to create an entry point and a project <code>Manifest.toml</code> file, which will retrieve the same dependencies for all operating systems on which the desktop application is developed. This makes it quick, predictable, and convenient for rapid iteration, which brings down the barriers to what a single developer can maintain. This was demonstrated for all major operating systems in my <a href="https://www.youtube.com/watch?v&#61;wICPVpDa7aw">JuliaCon 2024 AppBundler talk</a>. Furthermore, it is not limited to desktop applications. It can be used to deploy a server application on Linux via snap format or can also be used in Julia distributions with installed and precompiled dependencies where TTFX for large packages is a pain point in educational settings.</p> <p>The AppBundler story is not yet finished, with several challenges and opportunities on the horizon. Developers need to maintain bundling postprocessing toolchains for MacOS and Windows. On Windows, the toolchain setup is particularly nasty as it requires installing the whole SDK and then pinpointing the correct executable in a deeply nested folder structure. As those tools are not open source, they can&#39;t be distributed with BinaryBuilder, and hence <code>AppBundler.build</code>, a function that produces finalised bundles on respective host systems, puts a big burden in the long term as it would encode many assumptions. This also makes it burdensome to support CI workflows for testing and deployment. </p> <p>Open-source alternatives for MacOS have recently appeared, whereas Windows offers MSIX packaging software under an open-source license, albeit with limited documentation. If these open-source tools could be used instead of the proprietary alternatives, then the maintenance of <code>AppBundler.build</code>, a function that produces finalised bundles on the respective host systems, would become simple. Much like now, snap bundles can be created with <code>mksquashfs</code>, which is retrieved from Julia. This integration would facilitate the creation of GitHub action scripts for package releases upon codebase tagging and integration tests for early bug detection.</p> <p>Furthermore, successfully integrating these open-source tools could also enable the creation of finalised bundles on Linux for all desktop platforms. The missing piece would be cross-compilation support for Julia, which is anticipated in the future. This development would significantly ease the deployment of GUI applications across platforms. In the meantime, a prototype could be implemented where the application is precompiled during the first run. That would provide another use case for cross-compilation and could work as a catalyst for the cross-compilation support efforts.</p> <p>Generally, Julia&#39;s compilation capabilities have improved over time. The AppBundler uses PkgImages, which became relocatable only with Julia 1.11. Previously, the only compilation option was via SysImages, which continues to be exposed via PackageCompiler. PackageCompiler is slower to compile than PkgImages but can be essential to reduce startup times. Looking ahead to the future, we see that Julia will get the ability to be statically compiled via the Juliac project, which has shown promise in reducing binary sizes and being competitive with other statically compiled programming languages. All these options could be incorporated with the <code>AppBundler</code>, allowing a seamless switch between <code>None|PkgImages|SysImages|JuliaC</code> as compilation methods by passing a single structured keyword argument. </p> <p>One of the hard parts about GUI applications is their distribution. For applications to get accepted in Snap, MacOS or Windows marketplaces, they must use the least privileges to get favourable reviews. Using existing marketplaces can also promote discovery, which is important for new open-source projects. </p> <p>During few days after the JuliaCon hackathon, I managed to get MacOS sandboxing to work by furiously reproducing the sandboxing environment and found a single necessary entitlement:</p> <pre><code class="xml hljs"><span class=hljs-tag >&lt;<span class=hljs-name >key</span>&gt;</span>com.apple.security.temporary-exception.mach-lookup.global-name<span class=hljs-tag >&lt;/<span class=hljs-name >key</span>&gt;</span>
    <span class=hljs-tag >&lt;<span class=hljs-name >array</span>&gt;</span>
    <span class=hljs-tag >&lt;<span class=hljs-name >string</span>&gt;</span>com.apple.coreservices.launchservicesd<span class=hljs-tag >&lt;/<span class=hljs-name >string</span>&gt;</span>
<span class=hljs-tag >&lt;/<span class=hljs-name >array</span>&gt;</span></code></pre> <p>which was a hell of a lot of work to discover, even when using <code>ChatGPT</code>. This only happened to GUI applications and seems to have been absent for the game engine Nathan Daly used when submitting a game to the MacOS app store bundled and built with <a href="https://www.youtube.com/watch?v&#61;kSp6d3qSb3I"><code>ApplicationBuilder</code> presented on JuliaCon 2018</a>. One may inspect further why GUI frameworks like QML or Gtk need this and if it could be avoided.</p> <p>Similar work needs to resume using Snap format and MSIX in sandboxed environments. I managed to get GLFW to work, but QML failed to render it, so I opened <a href="https://github.com/JuliaGraphics/QML.jl/issues/191">a bug report</a>. Similar issues appeared with Gtk when loaded with OpenGL. The issue could be somewhere deep in how OpenGL is linked to QML when compiled, but who knows? It is going to be a bear to debug. Flatpack does not have such issues in the confined environment or has the same problem, which would be worth exploring. If the former is the case, I could write that this works on flatpack and hence snap ... prove me wrong at the snap discourse forum. However, I would need to make a flatpack-builder BinaryBuilder recipe to build flatpacks, which likely also involves compiling several of its dependencies.</p> <p>Resolving sandboxing issues is particularly important for MSIX bundles, as the installation experience when they are self-signed is horrid compared to MacOS or Linux. From what I have gathered, Windows certificates cost around 100...200 euros/year. Hence, distribution in the Windows app store can be a free alternative, but they should not use <code>fullTrust</code> privileges for favourable reviews. Here, the issue starts with Julia failing to launch, as reported in issue <a href="https://github.com/JuliaLang/julia/issues/52007">#52007</a>. There seems to be a clear path forward with explicitly making a launcher to load every DLL dependency. However, there is a possibility that the next set of difficulties would follow when starting GUI applications. In particular, Gtk applications don&#39;t run in the <code>fullTrust</code> environment, where the issue seems to be about assumptions on linking. This seems can be resolved easily, but it still needs to be done. </p> <p>During JuliaCon, Michael Ferbst raised an interesting issue: The DFTK library, being so large, takes significant time to compile when instantiated on students&#39; computers. This can also be a good use case for AppBundler, as it can precompile Julia&#39;s environment and expose the terminal as regular Julia does, which I have used extensively in debugging recipes. However, exposing this use case with API and documentation for creating such Julia distributions is essential. A logical extension would be to build Julia from the source and bundle it, but <code>juliaup</code> works well already.</p> <p>There are many opportunities to enhance the AppBundler&#39;s user experience and make it ideal for distributing GUI and CMD applications. Overcoming these challenges would simplify AppBundler&#39;s maintenance, allowing for the creation of CI integration tests. In addition, it would result in a more user-friendly distribution experience for Julia applications, comparable to that of electron application distribution. This improvement would reduce the barriers to scientific software development in Julia, which has traditionally relied on less modern and user-friendly technologies like C&#43;&#43;/Python. Additionally, it could expand Julia&#39;s ecosystem into nontraditional domains like <a href="https://peacefounder.org/CryptoGroups.jl/dev/">cryptographic applications</a> due to Julia&#39;s strong type safety and ease of use or games.</p> <p><a href="https://www.youtube.com/watch?v&#61;wICPVpDa7aw">See also my JuliaCon 2024 talk on AppBundler.jl</a> and <a href="https://discourse.julialang.org/t/ann-appbundler-jl-bundle-your-julia-gui-application/106971">follow new announcements and discussions on discourse</a>.</p> <p>You can also help to review my <a href="https://hackmd.io/@JanisErdmanis/Skl6zR-RR">NLNET application on hackmd.io</a>&#33;</p> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Janis Erdmanis. Last modified: September 27, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>