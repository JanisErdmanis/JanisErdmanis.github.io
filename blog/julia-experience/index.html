<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.png"> <title>Julia type system and multiple dispatch</title> <header> <div class=blog-name ><a href="/">Janis Erdmanis</a></div> <nav> <ul> <li><a href="/cv/">CV</a> <li><a href="/blog/">Blog</a> <li><a href="/bookshelf/">BookShelf</a> </ul> </nav> </header> <div class=post-meta >Nov 16, 2017 | 1596 Words</div> <div class=franklin-content > <h1 id=julia_type_system_and_multiple_dispatch ><a href="#julia_type_system_and_multiple_dispatch" class=header-anchor >Julia type system and multiple dispatch</a></h1> <p>Most programmers are familiar with productivity gains to have an interpreter, meaningful error messages, docstrings, and an easy procedure to make and install libraries. That is why Python was such a good thing in its time, and I was a strong advocator for its use in science. But then, in 2015, I made a switch to Julia &#40;then it was version 0.3&#41;, and I have never looked back. So I decided to make a blog post about Julia&#39;s essentials to give the real experience of what I value most about it: dynamic multiple dispatch, its type system, performance and ease of use in multicore environments.</p> <h2 id=multiple_dispatch ><a href="#multiple_dispatch" class=header-anchor >Multiple dispatch</a></h2> <p>Every useful computer program applies some operations to input and generates an output which can be represented in a list of machine instructions. Fortunately, we can make these programs by abstracting data structures into types and operations which act on them. Depending on the way we organise types and operations, we can write code in an object-oriented paradigm &#40;OOP&#41; or functional/imperative paradigm &#40;FP&#41; as <code>myfoo.hello&#40;&#41;</code> and <code>hello&#40;myfoo&#41;</code> is the same thing. Nevertheless, of the chosen paradigm, we spend more time on organising than on the benefits of the creative process.</p> <p>To see that, imagine that we have a set of types and a set of operations that act on these types. Sometimes we need to add more operations and ensure they work properly on all types, or we need to add more types and ensure that all operations work properly on them. Sometimes, however, we need to add both - and there lies the problem. Most of the mainstream programming languages only provide good tools to add new types and operations to an existing system without changing existing code. That is called the <em>expression problem</em>.</p> <p>Both - FP and OOP - suffer from the expression problem. In OOP, types can be easily added by class inheritance, but to add new operations &#40;methods&#41; to existing types, you need to edit the class where it is defined and decide under which class the method fits, taking a lot of mental effort; in FP operations are easy to add, but you would be forced to name them like <code>plusmytypeAmytypeB&#40;x, y&#41;</code> to keep track of what they do. Therefore it is hard to reuse existing operations for your newly defined types. &#40;Note that Rust comes around this issue with traits and the ability to implement multiple traits for a single type. In Java, on the other hand, one would need to edit the interface to support new behaviours&#41;.</p> <p>For example, consider what it would take to make a function written for integer and floating point types <code>myfuncInt64Float64&#40;x,y&#41;</code> available for your own types <code>BigInt</code> and <code>BigFloat</code>. Firstly you would copy and paste the function&#39;s code, change its name call and return types; for every function call on integer and floating types, you would need to replace the appropriate function call corresponding to the new types <code>BigInt</code> and <code>BigFloat</code>. In some situations, automating this process could be useful, but it would take a lot of effort to think about how the code can be generalised. It would be easier if types would not need to be specified, including function names, and the compiler &#40;or interpreter&#41; would choose the right function depending on passed types at runtime. One way to accomplish that is by writing function selection mechanisms or <em>generic functions</em> yourself, but it would be much nicer if the <em>generic functions</em> would be generated automatically from the functions you had already in the namespace - this is where dynamic multiple dispatch comes in handy.</p> <p>Dynamic multiple dispatch is a function selection mechanism which chooses the right function implementation &#40;function with specified types&#41; depending on their passed types on runtime &#40;the selection mechanism usually is not present at program running time because the compiler can reason the right type at compilation time&#41;. While it is similar to C&#43;&#43; overloading, it does not suffer from pitfalls which come from static rather than dynamic dispatch &#40;I will discuss that in the next subsection&#41;. So dynamic multiple dispatch makes it possible to reuse a lot of code when adding new operations for existing types, as all functions would share the same names.</p> <p>But that is not enough&#33; Adding new types is still hard because we usually want to base our type on the existing set of operations that type that already work on it and add only relevant data structure or operational differences. So that justifies the need for type inheritance and multiple dispatch over abstract types, which is the final ingredient to solve the expression problem. Interestingly the solution is based on extensive use of polymorphism as functions for different types share the same names and inheritance. So is Julia OOP or FP language?</p> <h2 id=static_dispatch ><a href="#static_dispatch" class=header-anchor >Static dispatch</a></h2> <p>C&#43;&#43; overloading is an example of static multiple dispatch because the right types must be guessed at the compilation time. But as I told you previously, that introduces pitfalls. I will try to illustrate them on a simple Julia program as my C&#43;&#43; is quite rusty:</p> <pre><code class="julia hljs">abstract Bar
type SubBar1 &lt;: Bar <span class=hljs-keyword >end</span>
type SubBar2 &lt;: Bar <span class=hljs-keyword >end</span>

fubar(b::Bar) = <span class=hljs-string >&quot;b is a Bar&quot;</span>
fubar(b::SubBar1) = <span class=hljs-string >&quot;b is a SubBar1&quot;</span>
fubar(b::SubBar2) = <span class=hljs-string >&quot;b is a SubBar2&quot;</span>

<span class=hljs-keyword >function</span> foo(x::Bar)
    <span class=hljs-keyword >return</span> fubar(x) 
<span class=hljs-keyword >end</span></code></pre> <p>If Julia would do static dispatch like C&#43;&#43;, the result of calling function <code>foo&#40;x&#41;</code> for both <code>x</code> types <code>SubBar1</code> and <code>SubBar2</code> would be &quot;b is a Bar&quot;. That does not help with the expression problem much, as we would need to define function <code>foo&#40;x&#41;</code> for each new type.</p> <p>In dynamic dispatch, appropriate methods for <code>x</code> are chosen, returning either &quot;b is a SubBar1&quot; or &quot;b is a SubBar2&quot;. And that is very useful for creating your types on top of existing ones and changing only meaningful parts of code without actually modifying it. That makes the code highly reusable in Julia and is a reason why C&#43;&#43; people could say that <em>Julia is C&#43;&#43; done right</em>.</p> <h2 id=single_dynamic_dispatch ><a href="#single_dynamic_dispatch" class=header-anchor >Single dynamic dispatch</a></h2> <p>The behaviour of single dynamic dispatch can be simulated in an object-oriented programming language like Python by transforming:</p> <p>hello&#40;myfoo&#41; -&gt; myfoo.hello&#40;&#41;</p> <p>So what difference would that make? The previous example can be implemented very easily as follows:</p> <pre><code class="python hljs"><span class=hljs-keyword >class</span> <span class="hljs-title class_">Bar</span>:
    <span class=hljs-keyword >pass</span>
<span class=hljs-keyword >class</span> <span class="hljs-title class_">SubBar1</span>(<span class="hljs-title class_ inherited__">Bar</span>):
    <span class=hljs-keyword >pass</span>
<span class=hljs-keyword >class</span> <span class="hljs-title class_">SubBar2</span>(<span class="hljs-title class_ inherited__">Bar</span>):
    <span class=hljs-keyword >pass</span>

Bar.fubar = <span class=hljs-keyword >lambda</span> <span class="hljs-variable language_">self</span>: println(<span class=hljs-string >&quot;Bar&quot;</span>)
SubBar1.fubar = <span class=hljs-keyword >lambda</span> <span class="hljs-variable language_">self</span>: println(<span class=hljs-string >&quot;SubBar1&quot;</span>)
SubBar2.fubar = <span class=hljs-keyword >lambda</span> <span class="hljs-variable language_">self</span>: println(<span class=hljs-string >&quot;SubBar2&quot;</span>)

<span class=hljs-keyword >def</span> <span class="hljs-title function_">foo</span>(<span class=hljs-params >x</span>):
    x.fubar()</code></pre> <p>so calling <code>foo&#40;x&#41;</code> with the object of <code>SubBar1</code> or <code>SubBar2</code> would result in the same behaviour as in dynamic dispatch.</p> <p>The difficulty lies in the problem that it is only a single dispatch. For example, consider classes which implement different kinds of matrices - ordinary, sparse, triangular - and you would like to implement multiplication between them. A code in Python would look as follows:</p> <pre><code class="python hljs"><span class=hljs-keyword >class</span> <span class="hljs-title class_">Matrix</span>:
    <span class=hljs-keyword >pass</span>
<span class=hljs-keyword >class</span> <span class="hljs-title class_">Sparse</span>:
    <span class=hljs-keyword >pass</span>
<span class=hljs-keyword >class</span> <span class="hljs-title class_">Triangular</span>:
    <span class=hljs-keyword >pass</span>

<span class=hljs-keyword >def</span> <span class="hljs-title function_">mul_Matrix_Sparse</span>(<span class=hljs-params >x,y</span>):
    <span class=hljs-keyword >pass</span>
<span class=hljs-keyword >def</span> <span class="hljs-title function_">mul_Sparse_Matrix</span>(<span class=hljs-params >x,y</span>):
    <span class=hljs-keyword >pass</span>
<span class=hljs-keyword >def</span> <span class="hljs-title function_">mul_Matrix_Triangular</span>(<span class=hljs-params >x,y</span>):
    <span class=hljs-keyword >pass</span>
<span class=hljs-keyword >def</span> <span class="hljs-title function_">mul_Triangular_Matrix</span>(<span class=hljs-params >x,y</span>):
    <span class=hljs-keyword >pass</span>
<span class=hljs-keyword >def</span> <span class="hljs-title function_">mul_Sparse_Triangular</span>(<span class=hljs-params >x,y</span>):
    <span class=hljs-keyword >pass</span>
<span class=hljs-keyword >def</span> <span class="hljs-title function_">mul_Triangular_Sparse</span>(<span class=hljs-params >x,y</span>):
    <span class=hljs-keyword >pass</span>

<span class=hljs-comment >### Ups! Forgot to implement multiplicaction by objects themselves</span>

<span class=hljs-keyword >def</span> <span class="hljs-title function_">__mul__Matrix</span>(<span class=hljs-params >x,y</span>):
    <span class=hljs-keyword >if</span> isinstace(y,Sparse):
        <span class=hljs-keyword >return</span> mul_Matrix_Sparse(x,y)
    elseif isinstace(y,Triangular):
        <span class=hljs-keyword >return</span> mul_Matrix_Triangular(x,y)
    <span class=hljs-keyword >else</span>
        <span class=hljs-keyword >assert</span>(<span class=hljs-string >&quot;Not implemented&quot;</span>)
Matrix.__mul__ = __mul__Matrix

<span class=hljs-keyword >def</span> <span class="hljs-title function_">__mul__Sparse</span>(<span class=hljs-params >x,y</span>):
    <span class=hljs-keyword >if</span> <span class=hljs-built_in >isinstance</span>(y,Matrix):
        <span class=hljs-keyword >return</span> mul_Sparse_Matrix(x,y)
    elseif <span class=hljs-built_in >isinstance</span>(y,Triangular):
        <span class=hljs-keyword >return</span> mul_Sparse_Triangular(x,y)
    <span class=hljs-keyword >else</span>:
        <span class=hljs-keyword >assert</span>(<span class=hljs-string >&quot;Not implemented&quot;</span>)
Sparse.__mul__ = __mul__Sparse

<span class=hljs-keyword >def</span> <span class="hljs-title function_">__mul__Triangular</span>(<span class=hljs-params >x,y</span>):
    <span class=hljs-keyword >is</span> <span class=hljs-built_in >isinstance</span>(y,Matrix):
        <span class=hljs-keyword >return</span> mul_Triangular_Matrix(x,y)
    elseif <span class=hljs-built_in >isinstance</span>(y,Sparse):
        <span class=hljs-keyword >return</span> mul_Triangular_Sparse(x,y)
    <span class=hljs-keyword >else</span>:
        <span class=hljs-keyword >assert</span>(<span class=hljs-string >&quot;Not implemented&quot;</span>)
Triangular.__mul__ = __mul__Triangular</code></pre> <p>The ugly part of the code above is the selection mechanism which is like a stone on your shoulders. For example, consider if you would like to implement a vector type and multiplications with all present objects. Firstly you would have to write corresponding functions which are necessary work. Then for each object selection mechanism, you would have to add <code>isinstance&#40;y, Vector&#41;,</code> which requires editing existing code. Also, adding operations allowing multiplying the same objects would require the same amount of work, and thus, we turn to the expression problem.</p> <p>On the contrary, the Julia code above would look as follows:</p> <pre><code class="julia hljs">abstract <span class=hljs-built_in >Matrix</span>
abstract Sparse
abstract Triangular

*(x::<span class=hljs-built_in >Matrix</span>,y::Sparse) = ...
*(x::<span class=hljs-built_in >Matrix</span>,y::Triangular) = ...
*(x::Sparse,y::Triangular) = ...
*(x::Sparse,y::<span class=hljs-built_in >Matrix</span>) = ...
*(x::Triangular,y::<span class=hljs-built_in >Matrix</span>) = ...
*(x::Triangular,y::Sparse) = ...</code></pre> <p>Not only is the code much shorter and easier to write but also much easier to manage as we don&#39;t need to write a dispatching mechanism ourselves. That is especially advantageous as to add new types and operations; we need to edit the code above. Therefore we have seen that dynamic dispatch over multiple arguments is essential for solving the expression problem.</p> <h2 id=resources ><a href="#resources" class=header-anchor >Resources</a></h2> <p>I was too lazy to research why I feel so uncomfortable doing stuff again in Python. Expression problem</p> <ul> <li><p><a href="http://matthewrocklin.com/blog/work/2014/02/25/Multiple-Dispatch">http://matthewrocklin.com/blog/work/2014/02/25/Multiple-Dispatch</a></p> <li><p><a href="https://medium.com/@Jernfrost/defining-custom-units-in-julia-and-python-513c34a4c971">https://medium.com/@Jernfrost/defining-custom-units-in-julia-and-python-513c34a4c971</a></p> <li><p><a href="https://discourse.julialang.org/t/dynamic-dispatch/6963">https://discourse.julialang.org/t/dynamic-dispatch/6963</a></p> <li><p><a href="https://news.ycombinator.com/item?id&#61;15565933">https://news.ycombinator.com/item?id&#61;15565933</a></p> <li><p><a href="https://medium.com/@franksands/why-is-object-oriented-programming-useful-with-an-rpg-example-javascript-and-java-670e2d1c5505">https://medium.com/@franksands/why-is-object-oriented-programming-useful-with-an-rpg-example-javascript-and-java-670e2d1c5505</a></p> <li><p><a href="http://www.stochasticlifestyle.com/type-dispatch-design-post-object-oriented-programming-julia/">http://www.stochasticlifestyle.com/type-dispatch-design-post-object-oriented-programming-julia/</a></p> <li><p><a href="https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53">https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53</a></p> <li><p><a href="http://www.stochasticlifestyle.com/like-julia-scales-productive-insights-julia-developer/">http://www.stochasticlifestyle.com/like-julia-scales-productive-insights-julia-developer/</a></p> <li><p><a href="http://www.stochasticlifestyle.com/comparison-differential-equation-solver-suites-matlab-r-julia-python-c-fortran/">http://www.stochasticlifestyle.com/comparison-differential-equation-solver-suites-matlab-r-julia-python-c-fortran/</a></p> <li><p><a href="https://devblogs.nvidia.com/parallelforall/gpu-computing-julia-programming-language/">https://devblogs.nvidia.com/parallelforall/gpu-computing-julia-programming-language/</a></p> <li><p><a href="http://nbviewer.jupyter.org/gist/StefanKarpinski/b8fe9dbb36c1427b9f22">http://nbviewer.jupyter.org/gist/StefanKarpinski/b8fe9dbb36c1427b9f22</a></p> <li><p><a href="https://discourse.julialang.org/t/julia-motivation-why-werent-numpy-scipy-numba-good-enough/2236/10">https://discourse.julialang.org/t/julia-motivation-why-werent-numpy-scipy-numba-good-enough/2236/10</a></p> <li><p><a href="https://en.wikipedia.org/wiki/Expression_problem">https://en.wikipedia.org/wiki/Expression_problem</a></p> <li><p><a href="https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions/">https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions/</a></p> <li><p><a href="https://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-2">https://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-2</a></p> <li><p><a href="https://blog.logentries.com/2016/12/solving-the-expression-problem/">https://blog.logentries.com/2016/12/solving-the-expression-problem/</a></p> </ul> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Janis Erdmanis. Last modified: July 07, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>